/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yufli <yufli@student.42barcelona.com>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/17 07:41:24 by yufli             #+#    #+#             */
/*   Updated: 2025/11/17 08:09:05 by yufli            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

void	ft_putstr(char *str)
{
	int	i;

	i = 0;
	while (str[i] != '\0')
		i++;
	write(1, str, i);
}

/* 这种写法其实比「一个字符一个字符输出」更高性能。
 * 指针 + 批量输出更快。*/

/* 以下两个写法你觉得有没有区别？如果有，区别在哪？
 *
 * 写法 A
 * int i = 0;
 * while (str[i] != '\0')
 * 	i++;
 *
 * 写法 B
 * while (*str != '\0')
 * 	str++;
 *
 * A 和 B 的行为在逻辑上完全相同吗？差异在哪？*/

/* 数组与指针在遍历行为上等价
 * 两者虽然做的事一样，但在本质上有一个关键区别。
 * 请看下面的两段代码
 *
 * char str[] = "hola";
 * 写法 A（索引遍历）
 * int i = 0;
 * while (str[i] != '\0')
 * 		i++;
 * 写法 B（指针遍历）
 * char *p = str;
 * while (*p != '\0')
 * 		p++;
 * 到这里，两者确实做的事情一样：从开头走到 '\0'。
 *
 * 但是……
 * 
 * 索引遍历（str[i]）——不会改变 str 本身
 * 字符数组的地址永远不变
 * 你只是在移动 “i 这个数字”
 * 指针遍历（*p）——会改变 p 指向的位置
 * p 一步一步向后移动
 * 最后 p 指向字符串末尾
 * 除非你自己保存原始指针，否则你 lost 了原来的地址
 * 这是之后你写 malloc/free、ft_strjoin、ft_split、GNL 时，最关键的基础。
 * 
 * 索引遍历：移动的是「数字 i」，不是指针本身
 * str[i] 通过计算：起始地址 + i 的偏移
 * str 本身永远指向同一块内存
 * i 变大，但 str 不变
 * 遍历结束后，你仍然知道字符串开头在哪里
 * 你不会丢失地址
 * 
 * 指针遍历：移动的是「指向的位置」，指针会走到后面
 * p++ 会真正让 p 指向下一块内存（地址改变）
 * p 最终指向 '\0'，你失去了原始头地址
 * 如果以后还要用头地址，你必须提前保存一份：
 * 
 * char *p = str;
 * char *head = p; // 保存原始地址
 * 
 * 这段代码会打印什么？
 * void	ft_print(char *s)
 * {
 * 		while (*s)
 *      	s++;
 * 		write(1, s, 5);
 * }
 *
 * 推导：
 * while(*s) 遍历后，s 会指向哪里？
 * 原始：`s -> 'h'`
 * `s++` 移动……
 * 最终：`s -> '\0'`（字符串末尾）
 *
 * write(1, s, 5) 会从 s（也就是 '\0'）开始打印5个字节
 * 也就是说，它会打印：
 * 第 1 个字节：`\0`（显示不出来）
 * 后四个字节：内存中紧跟在字符串后面的未知数据
 *
 * 输出 = **乱码 + 随机内存内容**
 * 所以：
 * 1. **不会打印整个字符串，而是打印末尾的 '\0' 开始的 5 个字节（乱码）**
 * 2. 不安全的原因也不是“因此应该用索引遍历”，而是：
 *
 * 真正的不安全原因
 * **指针遍历（s++）改变了 s 的值，使你失去了字符串的起始地址。**
 * 所以后面的 `write(1, s, 5)` 是从错误的位置开始打印的，从而读取非法内存。
 *
 * 但是：“所以应该用索引遍历” 是不对的
 * 指针遍历并不是错的。
* 错误的是遍历后使用了**已经偏移过的指针**。
* 正确写法应该是：
* void	ft_print(char *s)
* {
* 		char	*start = s;   // 保存头地址
* 
* 		while (*s)
* 			s++;
* 		write(1, start, s - start);  // 0 到长度的范围
* }
* 指针遍历是可以用的
* 不能在遍历后直接使用已偏移的指针作为起始地址
*
* 更新认知：
* 指针遍历不是不安全的
* 保存原始地址才是不安全的
* 索引遍历只是避免这个问题的一种方法，但不是唯一方法。
*/
