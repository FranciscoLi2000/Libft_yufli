/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_rev_int_tab.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yufli <yufli@student.42barcelona.com>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/17 08:11:26 by yufli             #+#    #+#             */
/*   Updated: 2025/11/17 08:22:42 by yufli            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * 数组是连续内存
 * 左右双指针
 * swap 的真正执行流程
 * “索引遍历 vs 指针遍历”的对比
 */

void	ft_rev_int_tab(int *tab, int size)
{
	int	tmp;
	int	i;

	i = 0;
	while(i < size / 2)
	{
		tmp = tab[i];
		tab[i] = tab[size - i - 1];
		tab[size - i - 1] = tmp;
		i++;
	}
}

/* size - i - 1 到底是怎么来的？为什么是 -1？为什么不是 -i？为什么不是 <=？*/
/* 数组内存模型（0-indexed）的可视化图像。 */
/* 一起画出数组（假设 size = 5）
 * 数组有 5 个元素，它们的下标是：
 * index:  0   1   2   3   4
 * value: [a] [b] [c] [d] [e]
 * 注意：
 * size = 5
 * 最后一个 index = size - 1 = 4 */

/* 反转的本质是什么？
 * 反转就是：
 * 把 0 和 4 交换
 * 把 1 和 3 交换
 * i = 2 不必动（位于中间）
 * 也就是：
 * i 和 (size - 1 - i)
 * 具体：
 * i	目标位置
 * 0	5 - 1 - 0 = 4
 * 1	5 - 1 - 1 = 3
 * 2	5 - 1 - 2 = 2 */

/* 用一行总结
 * 数组的最后一个元素永远是 index = size - 1
 * 反转就是左边第 i 个，与右边第 i 个对称位置交换
 * 右边第 i 个的下标就是： size - 1 - i
 * 所以才有 tab[size - 1 - i] */

/* 假设 size = 6：
 * index:  0   1   2   3   4   5
 * value: [a] [b] [c] [d] [e] [f]
 * 你要交换：
 * 0 ↔ 5 → size - 1 = 5 → 5 - 0 = 5
 * 1 ↔ 4 → size - 1 = 5 → 5 - 1 = 4
 * 2 ↔ 3 → size - 1 = 5 → 5 - 2 = 3
 * 所以对应公式 right_index = size - 1 - i; */

/* 最终答案
 * 为什么用 size - i - 1？
 * 因为：
 * 数组从 0 开始
 * 最后一个下标是 size - 1
 * 反转时，第 i 个与“倒数第 i 个”交换
 * 倒数第 i 个的下标就是 (size - 1) - i
*/
