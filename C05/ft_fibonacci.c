/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_fibonacci.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yufli <yufli@student.42barcelona.com>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/17 12:13:45 by yufli             #+#    #+#             */
/*   Updated: 2025/11/17 14:10:48 by yufli            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * # 1. 哪怕你已经理解逻辑，但有必要重申一下函数本质
 *
 * fib(n) = fib(n-1) + fib(n-2)
 * 
 * 这句话的意思是：
 * > “为了算一个 fib(n)，你必须算两个更小的问题：fib(n-1) 和 fib(n-2)。”
 *
 * 关键：**这两个子问题之间没有共享结果**。
 *
 * 这就是复杂度爆炸的根源。
 *
 * # 2. 什么是“递归树”？（最关键的概念）
 *
 * > 把每次的递归调用画成一棵树
 * > 每个节点代表一个调用
 * > 节点的两个孩子代表它递归调用的两个子问题
 *
 * 我们举一个小例子：`ft_fibonacci(5)`
 *
 * ## fib(5) 的递归树（完全展开）
 * ```
 * 			fib(5)
 * 			/	\
 * 		fib(4)		fib(3)
 * 		/	\	/	\
 * 	fib(3)		fib(2) fib(2)	fib(1)
 * 	/    \		/   \  /   \
 * fib(2)  fib(1) fib(1) fib(0) fib(1) fib(0)
 * /   \
 * fib(1) fib(0)
 * ```
 * **相同的值被重复计算多次：**
 * `fib(3)` 被算 **2 次**
 * `fib(2)` 被算 **3 次**
 * `fib(1)` 被算 **5 次**
 * `fib(0)` 被算 **3 次**
 * 这已经不正常了。
 *
 * # 3. 为什么这叫“指数级复杂度”？
 *
 * fib(5) → 15 次调用
 * fib(10) → 177 次调用
 * fib(20) → 21891 次调用
 * fib(30) → 2692537 次调用（270 万！！！）
 * 增长速度极快，这种增长叫：
 * > **指数级：O(2^n)**
 * 因为：
 * 每个 fib(n) 会产生两个子调用（像一棵二叉树）
 * 递归树的节点数量 ≈ 2ⁿ
 * 
 * # 为什么会指数爆炸
 *
 * return (ft_fibonacci(index - 1) + ft_fibonacci(index - 2)); 这行意味着：
 *
 * 要算 fib(5) → 你必须算 fib(4) 和 fib(3)
 * 要算 fib(4) → 你必须算 fib(3) 和 fib(2)
 * 但 fib(3) 前面已经算过一次……
 * > 递归每次都从零开始算，没有任何记忆，所以重复调用次数会成指数增长。
 *
 * # 4. 为什么 Fibonacci 是“最差的递归例子”？
 *
 * 因为它满足：
 * 1. **两个子调用**（不是一个）
 * 2. **两个子调用都会继续递归**
 * 3. **没有剪枝，没有缓存（memo）**
 * 4. **每个节点本身不做任何工作（只做递归）**
 * 5. **树状结构完全展开（非常深）**
 *
 * 这类递归被称为：
 * > **暴力递归（Brute Force Recursion）**
*
* # 5. 用一句话总结
*
* > Fibonacci 的递归版本不是为了效率，而是为了教学：
* > 让你看到“递归树”和“指数爆炸”是什么样子。
*
* # 6. 给你一个超级清晰的对比（秒懂）
*
* ## 迭代版 — O(n)
* 只做 n 步循环：
* f0 = 0
* f1 = 1
* for i in [2..n]: f = f0 + f1
*
* ## 递归版 — O(2^n)
* 做重复计算，像这样：
* fib(5) = fib(4) + fib(3)
* fib(4) = fib(3) + fib(2)
*  fib(3) = fib(2) + fib(1)
*  fib(2) = fib(1) + fib(0)
* ...
*  如果你把重复画出来，就是满二叉树（指数大爆炸）。
*/

/*
 * # 一、什么情况下你要立刻警觉：
 * 
 * ## 「可能进入暴力递归 / 指数级复杂度」？
 *
 * ### ✔ **情况 1：一个递归调用里包含两个以上的递归调用**
 *
 * 典型例子：
 * return solve(n - 1) + solve(n - 2);
 * 或：
 * dfs(x+1, y);
 * dfs(x, y+1);
 * 或：
 * for (...)
 * 	recurse(a, b-1);
 * 	for (...)
 * 	recurse(a-1, b);
 *
 * 危险信号：递归树是“分叉”的，而不是“链式”的。
 * 单一方向安全：factorial(n-1)
 *
 * 多方向危险：
 * fib(n-1), fib(n-2)
 * dfs 多方向走迷宫
 * 回溯探索所有可能
 *
 * ### ✔ **情况 2：子问题之间高度重复**
 *
 * 像 Fibonacci：
 * fib(5) → fib(4) 和 fib(3) → fib(3) 又要算一次 → fib(2) 又算很多次
 *
 * **重复是指数爆炸的根源。**
 * 提醒你自己一句话：
 * > 只要一个递归子问题在不同路径中会被重复计算，就要警惕暴力递归。
 *
 * ### ✔ **情况 3：没有“剪枝”（没有跳过明显无效的分支）**
 *
 * 例如：
 * 全排列（permutations）
 * 子集生成（subsets）
 * N 皇后（queens），不剪枝会非常慢
 * 搜索迷宫路径（DFS）
 * 数独、八数码、棋盘问题
 * 
 * 如果没有 `is_valid()` 之类的剪枝，必炸。
 *
 * ### ✔ **情况 4：递归结构是“组合爆炸”的模式**
 *
 * 比如：
 * 二叉树所有路径
 * 图所有路径
 * 字符串所有子序列
 * 全部子集 2^n
 * 全部排列 n!
 * 这类别不用计算就知道会爆炸。
 *
 * # 二、总结：一句话记住
 *
 * > **只要你的递归像“树”，而不是像“链”，你就要怀疑指数级爆炸。**
 *
 * 链式递归是安全的（O(n)）：n → n-1 → n-2 → ... → 1
 * 树状递归是危险的（O(2^n) 或更多）：
 * 				n
 * 			/		\
 * 			n-1		n-2
 * 			/ \		/ \
 *
 * # 三、如何优化？（超级重要）
 * 我们把优化分成 **三大类**，每一类都非常实用。
 *
 * # **优化方法 1：记忆化（Memoization）**
* 把已经算过的结果存下来：
* int	memo[50];
* int	fib(int n)
* {
    * if (memo[n] != -1)
	* return memo[n];
    * memo[n] = fib(n-1) + fib(n-2);
    * return memo[n];
* }
* 这样所有 fib(n) **只算一次**。
* 复杂度从 **O(2^n) → O(n)**
* 这是最常用、最有效的优化方法。
*
* # **优化方法 2：动态规划（DP）**
* 改成迭代，从小到大累加：
* dp[0] = 0;
* dp[1] = 1;
* for (i = 2; i <= n; i++)
* 	dp[i] = dp[i-1] + dp[i-2];
* 复杂度一样是 **O(n)**
* 空间可优化到 **O(1)**。
*
* # **优化方法 3：剪枝（Pruning）**
*
* 在搜索/回溯里使用：`is_valid()`
* 提前判断已无解
* 跳过重复
* 排序 + 剪枝
* 约束条件过滤
*
* 典型应用:
* 迷宫
* 八皇后/十皇后
* 二叉树搜索
* 图搜索
* 排列组合问题
*
* 剪枝的意义：
* 减少递归树的“规模”，把指数级压成更低层级。
*
* # **优化方法 4（附加）：数学公式 / 预计算**
*
* 某些问题直接有数学公式，比如 Fibonacci：
* Binet 公式
* 矩阵快速幂（O(log n)）
* 但这类方法不适合所有问题，只在数学类问题里出现。
*
* # 四、在你未来的项目里的实际应用
* 
* ### Libft：基本不涉及暴力递归。
*
* ### Get Next Line：无递归。
*
* ### ft_printf：无递归。
*
* ### Push_swap：非常重要：你要避免对 stack 做“所有顺序组合的递归搜索”（会炸）
*
* ### Minishell：解析 AST 树的时候你会遇到递归，但它是链式，不是树状爆炸
*
* ### CPP Modules：和递归无关。
* 
* ### Exam Rank 04（mini-printf）无递归。
*
* ### Exam Rank 05（micro-paint/flood fill）
* DFS/BFS 可能需要避免暴力递归。
*
* ### Exam Rank 06（mini-RT 或 philo）几乎不涉及暴力递归。
*
* 真正用到递归深度技能的是：C05（十皇后）
* 你的优化方法是剪枝：同列、同主对角线、同副对角线
*
* 算法类项目（不是 42，但以后会遇到）：
* 全排列
* 子集
* 图路径
* 树的 DFS
* 背包问题
* 搜索游戏解（A* / BFS / DFS）
*/
