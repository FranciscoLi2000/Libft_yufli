# Piscine_C
## Des de 42 Barcelona

开始把 Shell00/01 的 Unix 思维和之后 C00–C13 的语法与指针训练串起来理解了。

1.	Shell00/01 → Unix 基础能力建立
	•	已经会用终端、读 man、用权限、路径、wildcard、pipe/filter。
	•	已经理解「组合小工具解决复杂问题」的哲学。
2.	C00–C13 → 从语法速成到指针地狱前的预备训练
	•	C00: 基本输出
	•	C01: 指针、数组、swap、字符串基础
	•	C02–C03: 字符串函数全部自己造轮子
	•	C04-C05: 递归与数学函数
	•	C06–C07: main 参数、内存分配、字符串拼接、base 转换
	•	C08: struct 与自定义类型
	•	C09: Library & Makefile
	•	C10: 用系统调用做 cat/tail/hexdump
	•	C11: 函数指针与高阶函数
	•	C12: 单向链表
	•	C13: 二叉树
	学 C 语言语法，训练抽象思维、指针思维与内存模型。

##《算法导论》（CLRS）在讲排序算法时，会讲到三个核心概念：

### ① 最坏时间复杂度（worst case）

冒泡：O(n²)
插入排序：O(n²)
快速排序：O(n²)
归并排序：O(n log n)

### ② 平均时间复杂度（average case）

### ③ 最好时间复杂度（best case）

这里就和 optimized 冒泡排序相关。

### 《算法导论》会特别指出：

冒泡排序的优化版“最好情况”是 O(n)
因为如果数组有序，它只需要扫描一遍。
同理，插入排序的最好情况也是 O(n)（数组有序时，插入时不需要后移）。
所以 optimized 冒泡排序是教“算法渐进分析”和“输入分布敏感算法”的好例子。

### 结论：

**上界可以更干净地写成 `d <= 10 - (n - pos)`**（两者等价）

---

# ft_print_combn 目标回顾（问题是什么）

在递归 `build(pos, n, start, comb, ...)` 的第 `pos` 层，我们要为 `comb[pos]` 选择一个数字 `d`，且必须保证剩下的 `n - pos - 1` 个位置还能被后续严格递增的数字填满（数字从 0 到 9，共 10 个可选）。问：`d` 能选到多大（最大值是多少）？

---

# 直观推导（用“剩余槽位”和“可用数字”思路）

* 当前层要填的位置数（包含当前层）= `n - pos`。
  说明：例如 `n=4, pos=1` 时，你还要填第 1、2、3 三个位置 → 共 `4 - 1 = 3` 个位置。

* 可用的数字范围是 `d, d+1, d+2, ... , 9`（因为后续必须比 `d` 大），这个序列里可用数字的个数是 `10 - d`（0..9 共 10 个，去掉 0..d-1 就剩 10-d 个）。

* 要填满剩余 `n - pos` 个位置，**可用数字数量必须 ≥ 剩余位置数**：

```
	10 - d  >=  n - pos
```

* 解这个不等式求 `d` 的最大值：

```
	10 - d >= n - pos ⇔ -d >= n - pos - 10 ⇔ d <= 10 - (n - pos)
```

这就是为什么上界是 `10 - (n - pos)`。

---

# 把它变成你原来的写法看看等价性
```
	d <= 9 - (n - pos) + 1
```
化简：
```
	9 - (n - pos) + 1 = (9 + 1) - (n - pos) = 10 - (n - pos)
```

两者完全相同——只是原来写法把 `+1` 和 `9` 分开，显得不直观。

---

# 图形化（示例）

假设 `n = 4`（要选 4 个数），现在 `pos = 1`（还剩 3 个位置要填：pos=1,2,3 → 总 `n-pos = 3`）：

```
	可选数字： 0 1 2 3 4 5 6 7 8 9
	索引:      0 1 2 3 4 5 6 7 8 9
```

* 如果你选 `d = 7`，可用数字数 = `10 - 7 = 3` → 能填下 3 个位置（7,8,9） ✅
* 如果你选 `d = 8`，可用数字数 = `10 - 8 = 2` → 只够填 2 个位置，不够（需要 3） ❌

所以最大 `d` = `10 - (n - pos)` = `10 - 3 = 7`。
对应你的式子：`9 - (n - pos) + 1 = 9 - 3 + 1 = 7`，一致。

---

# 再举几个小例子快速印象（表格）

| n (总长度) | pos (当前) | 剩余位置 n-pos |        最大 d = 10 - (n-pos) |
| ------: | -------: | ---------: | -------------------------: |
|       3 |        0 |          3 | 7  → 最多从 0..7 开始（比如 7,8,9） |
|       3 |        1 |          2 | 8  → 第二位最多从 0..8（比如 a,8,9） |
|       3 |        2 |          1 |         9  → 最后一位可为 9（或更小） |
|       5 |        0 |          5 |   5  → 起始位最大是 5（5,6,7,8,9） |
---

# 在代码里怎么写更清晰？

把原公式换成更直观的形式：

```c
	for (d = start; d <= 10 - (n - pos); d++)
	{
		comb[pos] = d;
		build(pos + 1, n, d + 1, comb, first);
	}
```
或者你也可以先计算剩余位置 `r = n - pos; max = 10 - r;`，再循环 `d <= max`，可读性更好。

---

# 小结

* `n - pos` = 你**还需要填入几个数字（包含当前）**；
* 可用数字从 `d` 到 `9` 共 `10 - d` 个；
* 要满足 `10 - d >= n - pos` → 解得 `d <= 10 - (n - pos)`。这就是上界的来源。

C02 / C03 常见的**陷阱清单**和**快速检查点**

# 常见陷阱 & 快速检查点（适用于你发过来的那些函数）

1. **空字符串 / `""`**

* 输入为 `""` 时，函数是否按预期工作（例如 `is_*` 通常应返回 1；拷贝/拼接应留下 `'\0'`）？

2. **`n == 0`（针对 `strncpy`、`strncat`、`strncmp`）**

* `strncpy(..., n=0)` 不该写任何字节且返回 dest。
* `strncmp(..., n=0)` 应直接返回 0（表示相等）。
* `strncat(..., nb=0)` 不应追加任何字符。

3. **目标缓冲区大小 / 溢出（防范思路）**

* Piscine 作业一般不要求你检测 dest 容量，但工业代码必须。
养成在注释/文档里写明“假设 dest 足够大” 的习惯，或在 API 中抛出断言/返回错误。

4. **终止符 `\0` 的放置**

* 每次写入字符后最终都必须写 `dest[i] = '\0'`（尤其在循环退出路径多样时不要忘记）。

5. **字符比较的符号问题**

* 用 `unsigned char` 暂存 `str[i]` 再比较，
避免 `char` 带符号时出现负值比较导致错误（尤其是比较 `s1[i] - s2[i]` 时）。

6. **覆盖/重叠（overlap）问题**

* `strcpy/strcat` 在标准 C 中不保证在 src 与 dest 重叠时的行为；
你可以在注释里说明不支持重叠，或者实现时避免假设支持。

7. **返回值语义**

* `ft_strcpy/strncpy/strcat/strncat` 都应返回 `dest` 指针;
`strcmp/strncmp` 返回负/0/正差值
注意返回的是 `(unsigned char)s1 - (unsigned char)s2` 比较更安全。

8. **`is_printable` 范围**

* 可打印 ASCII 通常是 32..126（127 是 DEL，不可打印）。

9. **性能 / 可读性小技巧**

* 用 `size_t` 做索引，`const` 修饰不变参数，
变量命名语义化（`di`, `si` 比 `i1/i2` 好），
把简单的 `while` 合并为 `dest[d++] = src[s++]` 风格以降低行数但保持清晰。

# 快速验收测试（你每改完一函数就跑）

* 空字符串测试：`""`
* 边界字符测试：`\0`、`\n`、ASCII 127、字符 like `'A'`/`'a'`/`'0'`
* `n` 边界：`n = 0`, `n = 1`, `n = strlen(src)`, `n = strlen(src)+1`
* 比较函数：完全相等、前缀相等、不同首字符、长度不同但前缀相同
* 拷贝/拼接：dest 足够、dest 刚好足够（理论）、src 为空

---

# 为什么会从字符串跳到数学/算法

课程设计上：字符串、指针、IO 是「工具与语法基石」，
而后面的数值/递归题是用这些工具去表达更抽象的问题
例如把字符串变成数字 ft_atoi、任意进制转换 ft_convert_base、再到递归定义的阶乘/斐波那契/回溯）。
这些主题是能力迁移，不是突然换科目。参见 C04 的主题（字符串→数字→进制）和 C05 的递归/算法题目。

递归本质上是把“重复结构”用“函数自身”表示 — 数学式定义很短（如 f(n)=n*f(n-1)），
但把它改写成代码需要把抽象思想具体化为「基底（base case）」和「递推（recursive case）」。

# 快速心智模型（记住这三步）

* 画出递归树 / 走一遍小输入（手写或在纸上画节点），把函数调用看成栈上的一帧。
* 写出 base case（终止条件），把它放在最显眼的位置。
* 把复杂问题拆成更小的问题，并确保每次调用都比上一次“更接近” base case（比如 n→n-1）。

# 把递归变得不抽象 — 三个实战套路

## 先写迭代版，再写递归版

例：阶乘 factorial。先写循环版本 for (i=1..n) res*=i;，
理解流程后改写为递归 if (n<=1) return 1; return n * ft_recursive_factorial(n-1);。（C05 有这个练习）。

## 斐波那契：用递归→看效率→加记忆化（memo）或改为迭代

先做最直观的递归（会很慢）→ 在纸上画调用树，看重复子问题 → 用数组保存已算过的值（memo）或直接用迭代循环做 O(n)。
这能让你理解何时递归是合适的、何时需要优化。

## 回溯/搜索（Ten Queens）按模板练习

回溯核心：尝试（place）→ 校验（is_valid）→ 递归进入下一步→ 撤销（unplace/undo）。

练习步骤：先写一个 is_valid(col, row, placed[])，手写几步对比，写出递归模板。C05 的十皇后就是标准回溯练习。

## 调试与练习小技巧（让抽象具体化）

对每个递归调用都在最顶部加 printf("call n=%d\n", n);（或本地替代），用最小输入跑一遍，观察调用/返回顺序。
用纸画出调用树（比如 fib(5) 的树），标出重复子问题。

对回溯类：在放置和撤销时打印动作（place col,row / unplace），看是否有遗漏的撤销。

对于字符串题：写几个边界 case（空串、只有符号、包含非数字字符），逐条验证。

练习路线（把抽象降为可管理的小步）

复习 C02 的字符串函数：strcpy、strlcpy、strcapitalize 等（这些会帮你做 atoi / convert_base）。

C04：先做 ft_strlen、ft_putnbr、ft_atoi，把字符串→数字的流程掌握。

C05：先做迭代版本（factorial, power），再做递归版本；做 ft_fibonacci，然后尝试 memo；最后挑战 ft_ten_queens_puzzle（回溯）。

每做一个题，把「纸上步骤 → 代码 → 小输入跟踪」当作固定流程。


